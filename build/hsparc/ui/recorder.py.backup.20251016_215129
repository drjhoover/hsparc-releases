
# hsparc/ui/recorder.py
from __future__ import annotations

import os
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Dict, Tuple

from uuid import uuid4

from PySide6.QtCore import Qt, QUrl, Signal
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QPushButton, QComboBox, QCheckBox, QMessageBox, QStatusBar
)
from PySide6.QtMultimedia import (
    QMediaCaptureSession, QCamera, QAudioInput, QMediaRecorder, QMediaFormat
)
from PySide6.QtMultimediaWidgets import QVideoWidget

from hsparc.models import db as dbm
from hsparc.models.db import Recording, ObserverSession, InputStream, InputEvent, Case
from hsparc.ui.widgets.assign_dialog import AssignControllersDialog
from hsparc.input.gamepad import GamepadPoller

MEDIA_ROOT = Path.home() / ".local" / "share" / "hsparc" / "media"
MEDIA_ROOT.mkdir(parents=True, exist_ok=True)

class RecorderWindow(QMainWindow):
    recordingSaved = Signal(str)  # recording_id

    def __init__(self, parent=None, case_id: Optional[str] = None):
        super().__init__(parent)
        self.setWindowTitle("HSPARC — Recorder")
        self.resize(1100, 720)

        self.case_id = case_id
        self._recording_id: Optional[str] = None
        self._session_id: Optional[str] = None
        self._t0_monotonic: float = 0.0
        self._poller: Optional[GamepadPoller] = None

        # NEW: controller assignment (A/B -> {"path": str, "name": str})
        self.assigned: Dict[str, Optional[dict]] = {"A": None, "B": None}

        # ---- UI ----
        central = QWidget(self)
        root = QVBoxLayout(central)

        # top controls row — preserves your old layout/controls
        row = QHBoxLayout()
        row.addWidget(QLabel("Case:", self))
        self.case_combo = QComboBox(self)
        row.addWidget(self.case_combo, 1)

        self.chk_capture_pad = QCheckBox("Capture Controller Input", self)
        self.chk_capture_pad.setChecked(True)
        row.addWidget(self.chk_capture_pad)

        # NEW: first-input assignment button
        self.btn_assign = QPushButton("Assign Controllers…", self)
        row.addWidget(self.btn_assign)

        root.addLayout(row)

        # video preview — same as original
        self.video = QVideoWidget(self)
        root.addWidget(self.video, 10)

        # start/stop row — same as original
        ctrl = QHBoxLayout()
        self.btn_start = QPushButton("Start Recording", self)
        self.btn_stop  = QPushButton("Stop", self); self.btn_stop.setEnabled(False)
        ctrl.addWidget(self.btn_start)
        ctrl.addWidget(self.btn_stop)
        
        # Close button for kiosk mode
        self.btn_close_window = QPushButton("Close Recorder", self)
        self.btn_close_window.setStyleSheet("""
            QPushButton {
                background-color: #5bc0de;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #46b8da;
            }
        """)
        self.btn_close_window.clicked.connect(self.close)
        ctrl.addWidget(self.btn_close_window)
        ctrl.addStretch(1)
        root.addLayout(ctrl)

        self.setCentralWidget(central)
        self.setStatusBar(QStatusBar(self))

        # media capture session — same as original
        self.capture = QMediaCaptureSession(self)
        self.camera  = QCamera(self)
        self.audio   = QAudioInput(self)
        self.rec     = QMediaRecorder(self)
        self.capture.setCamera(self.camera)
        self.capture.setAudioInput(self.audio)
        self.capture.setRecorder(self.rec)
        self.capture.setVideoOutput(self.video)

        # format
        fmt = QMediaFormat()
        fmt.setFileFormat(QMediaFormat.MPEG4)
        self.rec.setMediaFormat(fmt)

        # wire
        self.btn_assign.clicked.connect(self._assign_controllers)
        self.btn_start.clicked.connect(self._start)
        self.btn_stop.clicked.connect(self._stop)

        # cases
        self._populate_cases()

        # ensure the window appears even if caller forgets show()
        self.show()

    # ---- assignment ----
    def _assign_controllers(self):
        """Open the first-input assignment dialog and capture participant names."""
        res = AssignControllersDialog.assign(self, "Assign Controllers")
        self.assigned = res
        a = res.get("A")["path"] if res.get("A") else "—"
        b = res.get("B")["path"] if res.get("B") else "—"
        self.statusBar().showMessage(f"Assigned A={a}  B={b}", 5000)

    # ---- start/stop ----
    def _start(self):
        # Create/resolve case
        self._ensure_case()

        # prepare output dir & file
        out_dir = MEDIA_ROOT / self.case_id
        out_dir.mkdir(parents=True, exist_ok=True)
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        out_file = out_dir / f"rec_{ts}.mp4"

        # DB: create Recording + ObserverSession
        now = datetime.now(timezone.utc)
        with dbm.get_session() as s:
            rec_id = uuid4().hex
            s.add(Recording(id=rec_id, case_id=self.case_id, created_utc=now, video_path=str(out_file), notes=""))
            sess_id = uuid4().hex
            s.add(ObserverSession(id=sess_id, recording_id=rec_id, created_utc=now, label="Recording Session"))
            s.commit()
        self._recording_id = rec_id
        self._session_id = sess_id

        # session-relative clock anchor
        self._t0_monotonic = time.monotonic()

        # Build poller-assignment dict and pre-create streams (+ INIT at t=0)
        assigned_map: Dict[str, Tuple[str, str]] = {}
        if self.chk_capture_pad.isChecked():
            for slot in ("A", "B"):
                slotv = self.assigned.get(slot)
                if not slotv:
                    continue
                realpath = slotv.get("path")
                alias = (slotv.get("name") or f"Participant {slot}").strip() or f"Participant {slot}"
                with dbm.get_session() as s:
                    st_id = uuid4().hex
                    s.add(InputStream(
                        id=st_id, session_id=sess_id, device_name=realpath,
                        profile_id="gamepad.evdev.v1", created_utc=now,
                        alias=alias, construct_mapping="{}"
                    ))
                    s.add(InputEvent(
                        id=uuid4().hex, recording_id=rec_id, session_id=sess_id,
                        stream_id=st_id, t_ms=0, kind="button", code="INIT",
                        value=None, is_press=None
                    ))
                    s.commit()
                assigned_map[realpath] = (st_id, alias)

        # start camera + recorder
        try:
            self.camera.start()
        except Exception:
            pass
        try:
            self.rec.setOutputLocation(QUrl.fromLocalFile(str(out_file)))
            self.rec.record()
        except Exception as e:
            QMessageBox.critical(self, "Recorder", f"Failed to start recording:\n{e}")
            return

        # start gamepad poller (only if capturing and we have assignments)
        if self.chk_capture_pad.isChecked() and assigned_map:
            self._poller = GamepadPoller(
                recording_id=rec_id,
                session_id=sess_id,
                time_source=lambda: (time.monotonic() - self._t0_monotonic) * 1000.0,
                assigned=assigned_map,
            )
            # start polling loop/thread if required by implementation
            if hasattr(self._poller, 'start'):
                try:
                    self._poller.start()
                except Exception:
                    pass

        self.btn_start.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self.statusBar().showMessage("Recording…", 2000)

        # notify app
        try:
            self.recordingSaved.emit(self._recording_id)
        except Exception:
            pass

    def _stop(self):
        # stop recorder first
        try:
            self.rec.stop()
        except Exception:
            pass
        try:
            self.camera.stop()
        except Exception:
            pass
        # stop poller
        try:
            if self._poller:
                try:
                    if hasattr(self._poller, 'stop'):
                        self._poller.stop()
                    if hasattr(self._poller, 'join'):
                        self._poller.join(timeout=1.0)
                except Exception:
                    pass
            self._poller = None
        except Exception:
            pass
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)
        self.statusBar().showMessage("Stopped.", 2000)

    # ---- helpers ----
    def _populate_cases(self):
        self.case_combo.clear()
        with dbm.get_session() as s:
            rows = list(s.query(Case).order_by(Case.created_utc).all())
            if not rows:
                cid = uuid4().hex
                s.add(Case(id=cid, label="Default", created_utc=datetime.now(timezone.utc)))
                s.commit()
                rows = [s.get(Case, cid)]
            for r in rows:
                self.case_combo.addItem(r.label, r.id)
        if self.case_id:
            idx = max(0, self.case_combo.findData(self.case_id))
            self.case_combo.setCurrentIndex(idx)
        else:
            idx = self.case_combo.currentIndex()
            if idx >= 0:
                self.case_id = self.case_combo.itemData(idx)

    def _ensure_case(self) -> str:
        if hasattr(self, "case_combo"):
            idx = self.case_combo.currentIndex()
            if idx >= 0:
                cid = self.case_combo.itemData(idx)
                if cid:
                    self.case_id = cid
                    return cid
        if self.case_id:
            return self.case_id
        with dbm.get_session() as s:
            row = s.query(Case).filter(Case.label == "Default").first()
            if row is None:
                cid = uuid4().hex
                s.add(Case(id=cid, label="Default", created_utc=datetime.now(timezone.utc)))
                s.commit()
                self.case_id = cid
            else:
                self.case_id = row.id
        return self.case_id

    def closeEvent(self, ev):
        try:
            self._stop()
        except Exception:
            pass
        super().closeEvent(ev)