# hsparc/ui/observer.py
from __future__ import annotations

import os
import time
from PySide6.QtWidgets import QDialog
import hashlib
from datetime import datetime, timezone
from typing import Optional, Dict, Tuple, List
from uuid import uuid4
from pathlib import Path

from PySide6.QtCore import Qt, QUrl, QEvent
from PySide6.QtWidgets import (, QDialog
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QMessageBox, QStatusBar, QSlider, QLineEdit, QCheckBox
)
from PySide6.QtGui import QKeyEvent, QPixmap
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput
from PySide6.QtMultimediaWidgets import QVideoWidget
import random
from typing import List
import cv2
import numpy as np
from PySide6.QtGui import QImage, QPixmap

from hsparc.models import db as dbm
from hsparc.models.db import Recording, ObserverSession, InputStream, InputEvent
from hsparc.ui.widgets.assign_dialog import AssignControllersDialog
from hsparc.input.gamepad import GamepadPoller

# Import recognition check components
try:
    from hsparc.ui.widgets.recognition_check_dialog import RecognitionCheckDialog
except ImportError:
    RecognitionCheckDialog = None
    print("[observer] Warning: RecognitionCheckDialog not available")

try:
    from hsparc.utils.frame_extractor import SimpleFrameExtractor
except ImportError:
    SimpleFrameExtractor = None
    print("[observer] Warning: SimpleFrameExtractor not available")


def _ms_to_clock(ms: int) -> str:
    if ms < 0:
        ms = 0
    s, ms = divmod(ms, 1000)
    m, s = divmod(s, 60)
    h, m = divmod(m, 60)
    if h:
        return f"{h:d}:{m:02d}:{s:02d}"
    return f"{m:02d}:{s:02d}"


# ========== Security Helpers ==========
def hash_pin(pin: str) -> str:
    """Hash a PIN using SHA256."""
    return hashlib.sha256(pin.encode('utf-8')).hexdigest()


def verify_pin(stored_hash: str, entered_pin: str) -> bool:
    """Verify an entered PIN against stored hash."""
    return hash_pin(entered_pin) == stored_hash


def log_access(case_id: str, action: str, success: bool = True):
    """Log security-relevant actions."""
    timestamp = datetime.utcnow().isoformat()
    status = "SUCCESS" if success else "FAILED"
    print(f"[ACCESS LOG] {timestamp} | Case: {case_id[:8]} | {action} | {status}")


class PinDialog(QMessageBox):
    """Simple dialog for entering case PIN."""

    def __init__(self, parent=None, title="Enter Case PIN", message="Enter the PIN:"):
        # remember thumbnail picks across calls for diversity
        self._thumb_history = []
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setText(message)
        self.setIcon(QMessageBox.Question)

        self.pin_input = QLineEdit()
        self.pin_input.setEchoMode(QLineEdit.Password)
        self.pin_input.setPlaceholderText("Enter 4-8 digit PIN")
        self.pin_input.setMaxLength(8)

        layout = self.layout()
        layout.addWidget(self.pin_input, 1, 1)

        self.addButton(QMessageBox.Ok)
        self.addButton(QMessageBox.Cancel)
        self.setDefaultButton(QMessageBox.Ok)

    def get_pin(self) -> str:
        return self.pin_input.text().strip()

    @staticmethod
    def get_pin_from_user(parent=None, title="Enter Case PIN", message="Enter the PIN:"):
        dialog = PinDialog(parent, title, message)
        dialog.pin_input.setFocus()
        if dialog.exec() == QMessageBox.Ok:
            return dialog.get_pin()
        return None


class ObserverWindow(QMainWindow):
    """
    Observer mode with lockdown and optional recognition check.
    """

    def __init__(self, parent=None, recording_id: Optional[str] = None,
                 session_id: Optional[str] = None, case_id: Optional[str] = None, **_kw):
        super().__init__(parent)

        self.recording_id: Optional[str] = recording_id
        self._session_id: Optional[str] = session_id
        self._case_id: Optional[str] = case_id
        self._poller: Optional[GamepadPoller] = None
        self.assigned: Dict[str, Optional[dict]] = {"A": None, "B": None}
        self._allow_close: bool = False

        # Recognition check state
        self._recognition_check_enabled: bool = False
        self.video_path: Optional[Path] = None

        # OBSERVER MODE LOCKDOWN
        self.setWindowFlags(
            Qt.Window |
            Qt.CustomizeWindowHint |
            Qt.WindowTitleHint |
            Qt.WindowStaysOnTopHint |
            Qt.WindowMaximizeButtonHint
        )
        self.setWindowTitle("HSPARC â€“ Observer Mode [LOCKED]")
        self.resize(1100, 680)
        self.setWindowModality(Qt.ApplicationModal)

        # ---- UI ----
        central = QWidget(self)
        root = QVBoxLayout(central)

        # Header with exit button
        header = QHBoxLayout()
        header_label = QLabel("Observer Mode")
        header_label.setStyleSheet("font-size:16px;font-weight:600;")
        header.addWidget(header_label)
        header.addStretch(1)

        self.btn_exit = QPushButton("ðŸ”’ Exit Observer Mode (Requires PIN)", self)
        self.btn_exit.setStyleSheet("""
            QPushButton {
                background-color: #d9534f;
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #c9302c;
            }
        """)
        self.btn_exit.clicked.connect(self._exit_with_pin)
        header.addWidget(self.btn_exit)
        root.addLayout(header)

        # Controls row
        top = QHBoxLayout()
        self.btn_assign = QPushButton("Assign Controllersâ€¦", self)

        # Recognition check checkbox
        self.chk_recognition = QCheckBox("Require Recognition Check", self)
        self.chk_recognition.setToolTip(
            "Show random frames from the video and ask participants\n"
            "if they recognize anyone before starting the session."
        )

        self.btn_start = QPushButton("Start Observer Session", self)
        self.btn_stop = QPushButton("Stop", self)
        self.btn_stop.setEnabled(False)

        top.addWidget(self.btn_assign)
        top.addWidget(self.chk_recognition)
        top.addWidget(self.btn_start)
        top.addWidget(self.btn_stop)
        top.addStretch(1)
        root.addLayout(top)

        # Video area
        self.video = QVideoWidget(self)
        root.addWidget(self.video, 10)

        # Transport: position + seek slider
        transport = QHBoxLayout()
        self.slider = QSlider(Qt.Horizontal, self)
        self.slider.setRange(0, 0)
        self.slider.setEnabled(False)
        self.lbl_pos = QLabel("00:00", self)
        self.lbl_dur = QLabel("00:00", self)
        transport.addWidget(self.lbl_pos)
        transport.addWidget(self.slider, 1)
        transport.addWidget(self.lbl_dur)
        root.addLayout(transport)

        # Status
        self.setCentralWidget(central)
        self.setStatusBar(QStatusBar(self))
        self.lbl_status = QLabel("Idle. Click 'Start Observer Session' to begin.", self)
        root.addWidget(self.lbl_status)

        # Media player
        self.player = QMediaPlayer(self)
        self.audio = QAudioOutput(self)
        self.player.setVideoOutput(self.video)
        self.player.setAudioOutput(self.audio)

        # Wire signals
        self.btn_assign.clicked.connect(self._assign)
        self.btn_start.clicked.connect(self._start)
        self.btn_stop.clicked.connect(self._stop)
        self.player.positionChanged.connect(self._on_position)
        self.player.durationChanged.connect(self._on_duration)
        self.slider.sliderMoved.connect(self._on_slider_moved)

        # Load video if recording_id given
        if self.recording_id:
            try:
                with dbm.get_session() as s:
                    rec = s.get(Recording, self.recording_id)
                    if rec and rec.video_path and os.path.exists(rec.video_path):
                        self.video_path = Path(rec.video_path)
                        self.player.setSource(QUrl.fromLocalFile(str(self.video_path)))
                        self.statusBar().showMessage(f"Loaded video: {rec.video_path}", 4000)
                    else:
                        self.statusBar().showMessage("No video found for this recording.", 4000)
            except Exception as e:
                self.statusBar().showMessage(f"Failed to load video: {e}", 5000)

        from hsparc.ui.common import show_fullscreen_or_center
        show_fullscreen_or_center(self, True)

        self._prompt_initial_assignment()

    def _prompt_initial_assignment(self):
        """Prompt researcher to assign controllers before starting observer session."""
        reply = QMessageBox.question(
            self,
            "Assign Controllers",
            "Observer mode requires at least one controller to capture input.\n\n"
            "Would you like to assign controllers now?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            self._assign()
            if not self.assigned.get("A") and not self.assigned.get("B"):
                QMessageBox.warning(
                    self,
                    "No Controllers Assigned",
                    "At least one controller must be assigned for observer mode.\n\n"
                    "Exiting observer mode."
                )
                self._allow_close = True
                self.close()
        else:
            QMessageBox.information(
                self,
                "Observer Mode Cancelled",
                "Observer mode requires controller assignment.\n\n"
                "Exiting observer mode."
            )
            self._allow_close = True
            self.close()

    def keyPressEvent(self, event: QKeyEvent):
        """Block Alt+Tab, Alt+F4, and other escape combinations."""
        if event.modifiers() & Qt.AltModifier and event.key() == Qt.Key_Tab:
            event.ignore()
            return
        if event.modifiers() & Qt.AltModifier and event.key() == Qt.Key_F4:
            event.ignore()
            return
        if (event.modifiers() & Qt.ControlModifier and
                event.modifiers() & Qt.AltModifier and
                event.key() == Qt.Key_Delete):
            event.ignore()
            return
        if event.key() == Qt.Key_Escape:
            event.ignore()
            return

        super().keyPressEvent(event)

    def _exit_with_pin(self):
        """Exit observer mode - requires case PIN if case is locked."""
        self._stop()

        if not self._case_id:
            self._force_close()
            return

        with dbm.get_session() as s:
            case = s.query(dbm.Case).filter_by(id=self._case_id).first()
            if not case:
                self._force_close()
                return

            if getattr(case, 'is_locked', False) and getattr(case, 'security_hash', None):
                attempts = 0
                max_attempts = 3

                while attempts < max_attempts:
                    pin = PinDialog.get_pin_from_user(
                        self,
                        "Exit Observer Mode",
                        "Enter case PIN to return to main application:"
                    )

                    if pin is None:
                        log_access(self._case_id, "OBSERVER_EXIT_CANCELLED")
                        return

                    if verify_pin(case.security_hash, pin):
                        log_access(self._case_id, "OBSERVER_EXIT_GRANTED")
                        self._force_close()
                        return
                    else:
                        attempts += 1
                        remaining = max_attempts - attempts
                        log_access(self._case_id, f"OBSERVER_EXIT_DENIED_ATTEMPT_{attempts}", success=False)

                        if remaining > 0:
                            QMessageBox.warning(
                                self,
                                "Incorrect PIN",
                                f"Incorrect PIN.\n{remaining} attempt(s) remaining."
                            )
                        else:
                            QMessageBox.critical(
                                self,
                                "Access Denied",
                                "Maximum attempts exceeded.\nCannot exit observer mode."
                            )
                            return
            else:
                self._force_close()

    def _force_close(self):
        """Actually close the window, bypassing the closeEvent block."""
        self._allow_close = True
        self.close()

    def _assign(self):
        """Assign controllers."""
        self.assigned = AssignControllersDialog.assign(self, "Assign Controllers")
        a = (self.assigned.get("A") or {}).get("path") if self.assigned.get("A") else "â€“"
        b = (self.assigned.get("B") or {}).get("path") if self.assigned.get("B") else "â€“"
        print(f"[observer] assigned A={a}  B={b}")
        self.statusBar().showMessage(f"Assigned A={a}  B={b}", 4000)

    def _start(self):
        """Start observer session - with optional recognition check."""
        if not self.recording_id:
            QMessageBox.warning(self, "Observer", "No recording selected.\nOpen a recording first.")
            return

        if not self.assigned.get("A") and not self.assigned.get("B"):
            QMessageBox.warning(
                self,
                "No Controllers Assigned",
                "Please assign at least one controller before starting the observer session."
            )
            return

        # Check if recognition check is required
        if self.chk_recognition.isChecked():
            self._start_with_recognition_check()
        else:
            self._start_session()

    def _start_with_recognition_check(self):
        """Start session with recognition check."""
        print("[observer] Starting with recognition check...")

        if not self.video_path or not self.video_path.exists():
            QMessageBox.critical(
                self,
                "Video Not Found",
                "Cannot perform recognition check - video file not found."
            )
            return

        if SimpleFrameExtractor is None or RecognitionCheckDialog is None:
            QMessageBox.warning(
                self,
                "Feature Unavailable",
                "Recognition check feature is not available.\n"
                "Starting session without recognition check."
            )
            self._start_session()
            return

        # Extract random frames
        self.lbl_status.setText("Extracting video frames for recognition check...")
        self.statusBar().showMessage("Extracting frames...", 2000)

        try:
            frames = self._extract_frames()

            if not frames or len(frames) < 3:
                QMessageBox.warning(
                    self,
                    "Frame Extraction Failed",
                    f"Could not extract enough frames from video (got {len(frames)}/3).\n"
                    "Starting session without recognition check."
                )
                self._start_session()
                return

            print(f"[observer] Extracted {len(frames)} frames")

            # Show recognition check dialog
            self._show_recognition_check_dialog(frames)

        except Exception as e:
            print(f"[observer] Frame extraction error: {e}")
            import traceback
            traceback.print_exc()

            QMessageBox.critical(
                self,
                "Recognition Check Failed",
                f"Could not perform recognition check:\n{e}\n\n"
                "Starting session without recognition check."
            )
            self._start_session()

    def _extract_frames(self, count: int = 3) -> List[QPixmap]:
        """Diverse frame sampler across the whole clip; avoids repeats."""
        path = str(self.video_path)
        if not path:
            return []
        cap = cv2.VideoCapture(path)
        if not cap.isOpened():
            print("[observer] Could not open video for frame extraction:", path)
            return []
        fps = cap.get(cv2.CAP_PROP_FPS) or 30.0
        frames_total = cap.get(cv2.CAP_PROP_FRAME_COUNT) or 0
        duration = (frames_total / fps) if fps > 0 else 0.0
        if duration <= 0:
            cap.release()
            return []
        import numpy as _np, random as _rand
        bins = _np.linspace(0.0, duration, num=count + 2, dtype=float)[1:-1]
        rng = _rand.Random()
        picks_sec = []
        min_gap = max(0.75, duration / 40.0)
        if len(self._thumb_history) > 60:
            self._thumb_history = self._thumb_history[-30:]
        for center in bins:
            half = (duration / (count + 1)) * 0.10
            cand = max(0.0, min(duration - 1e-3, center + rng.uniform(-half, half)))
            for _ in range(10):
                if all(abs(cand - h) >= min_gap for h in self._thumb_history):
                    break
                cand = max(0.0, min(duration - 1e-3, cand + rng.uniform(min_gap * 0.25, min_gap * 0.75)))
            picks_sec.append(cand)
        pixmaps = []
        for t in picks_sec:
            frame_idx = int(round(t * fps))
            cap.set(cv2.CAP_PROP_POS_FRAMES, max(0, frame_idx))
            ok, frame = cap.read()
            if not ok or frame is None:
                continue
            rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            h, w, ch = rgb.shape
            bytes_per_line = ch * w
            qimg = QImage(rgb.data, w, h, bytes_per_line, QImage.Format.Format_RGB888)
            pixmaps.append(QPixmap.fromImage(qimg.copy()))
            self._thumb_history.append(t)
        cap.release()
        return pixmaps[:count]

    def _show_recognition_check_dialog(self, frames: List[QPixmap]):
        """Show the recognition check dialog."""
        dialog = RecognitionCheckDialog(
            parent=self,
            frames=frames,
            assigned_controllers=self.assigned,
            regenerate_callback=lambda: self._extract_frames(count=3)
        )
        dialog.setModal(True)
        dialog.setAttribute(Qt.WA_DeleteOnClose, True)
        dialog.check_completed.connect(self._handle_recognition_result)
        dialog.exec()
def _handle_recognition_result(self, passed: bool):
        # Defensive: ensure any lingering recognition dialog is closed
        try:
            for child in self.findChildren(QDialog):
                if child.isModal():
                    child.close()
        except Exception:
            pass

        """Handle recognition check result."""
        print(f"[observer] Recognition check result: {'PASSED' if passed else 'FAILED'}")

        # Create session first to store the check result
        if not self._session_id:
            now = datetime.now(timezone.utc)
            with dbm.get_session() as s:
                sess_id = uuid4().hex
                s.add(ObserverSession(
                    id=sess_id,
                    recording_id=self.recording_id,
                    created_utc=now,
                    label="Observer Session",
                    recognition_check_required=True,
                    recognition_check_passed=passed,
                    recognition_check_timestamp=datetime.utcnow().isoformat()
                ))
                s.commit()
            self._session_id = sess_id
        else:
            # Update existing session
            try:
                with dbm.get_session() as s:
                    session = s.query(ObserverSession).filter_by(id=self._session_id).first()
                    if session:
                        session.recognition_check_required = True
                        session.recognition_check_passed = passed
                        session.recognition_check_timestamp = datetime.utcnow().isoformat()
                        s.commit()
            except Exception as e:
                print(f"[observer] Failed to update session with recognition result: {e}")

        if passed:
            # Continue with normal session start
            print("[observer] Recognition check passed - starting session")
            self._start_session()
        else:
            # Recognition check FAILED - DO NOT START SESSION
            print("[observer] Recognition check FAILED - session will NOT start")

            self.lbl_status.setText(
                "âš ï¸ Recognition Check Failed\n\n"
                "A participant recognized someone in the video.\n"
                "No video playback or data recording will occur.\n\n"
                "Please consult with the researcher."
            )
            self.lbl_status.setStyleSheet("color: #d32f2f; font-size: 16px; font-weight: bold;")

            # CRITICAL: Disable start button to prevent session from starting
            self.btn_start.setEnabled(False)
            self.btn_stop.setEnabled(False)

            # Keep controller assignment enabled so researcher can try different participants
            self.btn_assign.setEnabled(True)
            self.chk_recognition.setEnabled(True)

            # Show message to researcher
            QMessageBox.warning(
                self,
                "Recognition Check Failed",
                "A participant recognized someone in the video.\n\n"
                "The observer session will NOT start.\n"
                "No video playback or data recording will occur.\n\n"
                "Options:\n"
                "â€¢ Exit observer mode (requires PIN)\n"
                "â€¢ Try with different participants\n"
                "â€¢ Select a different video/case",
                QMessageBox.Ok
            )

    def _start_session(self):
        """Actually start the observer session (after recognition check if needed)."""
        print("[observer] _start_session() called")

        # CRITICAL SAFEGUARD: If recognition check was required and failed, DO NOT START
        if self.chk_recognition.isChecked() and self._session_id:
            with dbm.get_session() as s:
                session = s.query(ObserverSession).filter_by(id=self._session_id).first()
                if session and session.recognition_check_passed == False:
                    print("[observer] BLOCKED: Recognition check failed, refusing to start session")
                    QMessageBox.critical(
                        self,
                        "Session Blocked",
                        "Cannot start session - recognition check failed.\n\n"
                        "The participant recognized someone in the video."
                    )
                    return

        now = datetime.now(timezone.utc)

        # Create new session if none provided (and recognition check not done)
        if not self._session_id:
            with dbm.get_session() as s:
                sess_id = uuid4().hex
                s.add(ObserverSession(
                    id=sess_id,
                    recording_id=self.recording_id,
                    created_utc=now,
                    label="Observer Session",
                    recognition_check_required=self.chk_recognition.isChecked(),
                    recognition_check_passed=None if not self.chk_recognition.isChecked() else True
                ))
                s.commit()
            self._session_id = sess_id

        # Build assigned map and pre-create streams + INIT at current playback time
        t0 = int(self.player.position())
        assigned_map: Dict[str, Tuple[str, str]] = {}
        for slot in ("A", "B"):
            slotv = self.assigned.get(slot)
            if not slotv:
                continue
            realpath = slotv.get("path")
            alias = (slotv.get("name") or f"Participant {slot}").strip() or f"Participant {slot}"

            with dbm.get_session() as s:
                st_id = uuid4().hex
                s.add(InputStream(
                    id=st_id,
                    session_id=self._session_id,
                    device_name=realpath,
                    profile_id="gamepad.evdev.v1",
                    created_utc=now,
                    alias=alias,
                    construct_mapping="{}"
                ))
                s.add(InputEvent(
                    id=uuid4().hex,
                    recording_id=self.recording_id,
                    session_id=self._session_id,
                    stream_id=st_id,
                    t_ms=t0,
                    kind="button",
                    code="INIT",
                    value=None,
                    is_press=None
                ))
                s.commit()

            assigned_map[realpath] = (st_id, alias)

        # Start poller if we have assignments
        if assigned_map:
            self._poller = GamepadPoller(
                recording_id=self.recording_id,
                session_id=self._session_id,
                time_source=lambda: float(self.player.position()),
                assigned=assigned_map,
            )
            if hasattr(self._poller, "start"):
                try:
                    self._poller.start()
                except Exception:
                    pass

        # Start playback automatically
        print("[observer] Starting video playback")
        try:
            self.player.play()
        except Exception as e:
            print(f"[observer] Failed to start playback: {e}")
            pass
        self.slider.setEnabled(True)

        # DISABLE controller assignment and recognition check during session
        self.btn_assign.setEnabled(False)
        self.chk_recognition.setEnabled(False)
        self.btn_start.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self.lbl_status.setText("Observingâ€¦ (logging aligned to video)")
        self.lbl_status.setStyleSheet("")  # Reset style
        self.statusBar().showMessage("Observer running", 2000)

    def _stop(self):
        """Stop the observer session."""
        try:
            self.player.pause()
        except Exception:
            pass
        try:
            if self._poller:
                if hasattr(self._poller, "stop"):
                    self._poller.stop()
                if hasattr(self._poller, "join"):
                    self._poller.join(timeout=1.0)
        except Exception:
            pass
        self._poller = None
        self.slider.setEnabled(False)

        # RE-ENABLE controller assignment after session stops
        self.btn_assign.setEnabled(True)
        self.chk_recognition.setEnabled(True)
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)
        self.lbl_status.setText("Stopped.")

    def _on_position(self, pos: int):
        try:
            self.slider.blockSignals(True)
            self.slider.setValue(pos)
            self.lbl_pos.setText(_ms_to_clock(pos))
        finally:
            self.slider.blockSignals(False)

    def _on_duration(self, dur: int):
        self.slider.setRange(0, dur if dur and dur > 0 else 0)
        self.lbl_dur.setText(_ms_to_clock(dur))

    def _on_slider_moved(self, pos: int):
        try:
            self.player.setPosition(pos)
        except Exception:
            pass

    def closeEvent(self, ev):
        """Prevent ALL closing attempts without PIN."""
        if self._allow_close:
            ev.accept()
            return

        ev.ignore()
        QMessageBox.warning(
            self,
            "Observer Mode Locked",
            "Observer mode is locked.\n\n"
            "Use the 'Exit Observer Mode' button and enter the case PIN to exit."
        )