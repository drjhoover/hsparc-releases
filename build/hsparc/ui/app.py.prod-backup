# hsparc/ui/app.py
import sys
import os
import shutil
import hashlib
import subprocess
import json
import zipfile
import time
from pathlib import Path
from datetime import datetime
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

from PySide6.QtCore import Qt, QUrl, QObject, QEvent
from PySide6.QtGui import QPalette, QBrush, QPixmap, QFont
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel,
    QPushButton, QListWidget, QListWidgetItem, QHBoxLayout,
    QInputDialog, QMessageBox, QFileDialog, QStackedLayout, QLineEdit,
    QProgressDialog, QComboBox, QSlider
)
from PySide6.QtMultimedia import QMediaPlayer, QAudioOutput, QMediaDevices
from PySide6.QtMultimediaWidgets import QVideoWidget

from hsparc.models import db as dbm
from hsparc.ui.common import new_uuid, make_cover_widget
from hsparc.ui.config import DEFAULT_AUDIO_VOLUME
from hsparc.ui.observer import ObserverWindow
from hsparc.ui.researcher import ResearcherWindow
from hsparc.ui.recorder import RecorderWindow
from hsparc.ui.global_av_manager import GlobalAVManager
from hsparc.ui.av_settings_dialog import AVSettingsDialog


# ========== Security Helpers ==========
def hash_pin(pin: str) -> str:
    """Hash a PIN using SHA256."""
    return hashlib.sha256(pin.encode('utf-8')).hexdigest()


def verify_pin(stored_hash: str, entered_pin: str) -> bool:
    """Verify an entered PIN against stored hash."""
    return hash_pin(entered_pin) == stored_hash


def log_access(study_id: str, action: str, success: bool = True):
    """Log security-relevant actions."""
    timestamp = datetime.utcnow().isoformat()
    status = "SUCCESS" if success else "FAILED"
    print(f"[ACCESS LOG] {timestamp} | Study: {study_id[:8]} | {action} | {status}")


# ========== Encryption Helpers ==========
def derive_key_from_pin(pin: str, salt: bytes) -> bytes:
    """Derive an AES-256 encryption key from a PIN using PBKDF2."""
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
        backend=default_backend()
    )
    return kdf.derive(pin.encode('utf-8'))


def encrypt_file(file_path: str, pin: str, output_path: str):
    """Encrypt a file using AES-256-GCM with PIN-derived key."""
    salt = os.urandom(16)
    iv = os.urandom(12)
    key = derive_key_from_pin(pin, salt)

    with open(file_path, 'rb') as f:
        plaintext = f.read()

    cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()

    with open(output_path, 'wb') as f:
        f.write(salt)
        f.write(iv)
        f.write(encryptor.tag)
        f.write(ciphertext)


def decrypt_file(encrypted_path: str, pin: str, output_path: str) -> bool:
    """Decrypt a file using AES-256-GCM. Returns True if successful."""
    try:
        with open(encrypted_path, 'rb') as f:
            salt = f.read(16)
            iv = f.read(12)
            tag = f.read(16)
            ciphertext = f.read()

        key = derive_key_from_pin(pin, salt)
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()

        with open(output_path, 'wb') as f:
            f.write(plaintext)

        return True
    except Exception:
        return False


# ========== PIN Dialog ==========
class PinDialog(QMessageBox):
    """Simple dialog for entering study PIN."""

    def __init__(self, parent=None, title="Enter Study PIN", message="Enter the PIN to access this study:"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setText(message)
        self.setIcon(QMessageBox.Question)

        self.pin_input = QLineEdit()
        self.pin_input.setEchoMode(QLineEdit.Password)
        self.pin_input.setPlaceholderText("Enter 4-8 digit PIN")
        self.pin_input.setMaxLength(8)

        layout = self.layout()
        layout.addWidget(self.pin_input, 1, 1)

        self.addButton(QMessageBox.Ok)
        self.addButton(QMessageBox.Cancel)
        self.setDefaultButton(QMessageBox.Ok)

    def get_pin(self) -> str:
        return self.pin_input.text().strip()

    @staticmethod
    def get_pin_from_user(parent=None, title="Enter Study PIN", message="Enter the PIN:"):
        dialog = PinDialog(parent, title, message)
        dialog.pin_input.setFocus()
        if dialog.exec() == QMessageBox.Ok:
            return dialog.get_pin()
        return None


# ========== Kiosk Event Filter ==========
class KioskEventFilter(QObject):
    """Block Alt+Tab, Alt+F4, and other escape key combos in kiosk mode."""

    def eventFilter(self, obj, event):
        if event.type() == QEvent.KeyPress:
            if event.modifiers() & Qt.AltModifier:
                if event.key() in (Qt.Key_Tab, Qt.Key_F4, Qt.Key_F1, Qt.Key_F2):
                    return True
            if (event.modifiers() & Qt.ControlModifier and
                    event.modifiers() & Qt.AltModifier and
                    event.key() == Qt.Key_Delete):
                return True
        return False


# ========== Background Window ==========
class BackgroundWindow(QLabel):
    """Background window showing HSPARC logo."""

    def __init__(self):
        super().__init__()

        # Try to load background image
        bg_path = Path("/opt/hsparc/resources/hsparc_background.jpg")
        if bg_path.exists():
            pixmap = QPixmap(str(bg_path))
            self.setPixmap(pixmap)
            self.setScaledContents(True)
            print(f"[main] Set background image: {bg_path}")
        else:
            # Fallback to black background
            self.setStyleSheet("background-color: black;")
            print(f"[main] Background image not found: {bg_path}")

        # Make it full screen and behind other windows
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnBottomHint)
        self.showFullScreen()


# ========== Main Window ==========
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.kiosk_mode = os.environ.get("HSPARC_KIOSK", "0") == "1"

        if self.kiosk_mode:
            self.setWindowTitle("HSPARC")
            self.setWindowFlags(Qt.Window | Qt.FramelessWindowHint)
            self.showFullScreen()
        else:
            self.setWindowTitle("HSPARC (M0)")
            self.resize(1000, 650)

        self._child_windows = []

        # Create menu bar with styled settings button
        menubar = self.menuBar()
        
        # Style the menubar
        menubar.setStyleSheet("""
            QMenuBar {
                background-color: #f8f9fa;
                padding: 4px;
            }
            QMenuBar::item {
                padding: 8px 16px;
                background: transparent;
                border-radius: 4px;
            }
            QMenuBar::item:selected {
                background: #e9ecef;
            }
        """)
        
        settings_menu = menubar.addMenu("‚öôÔ∏è  Settings")
        settings_menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #ddd;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: white;
            }
        """)
        
        av_settings_action = settings_menu.addAction("üé§ Audio/Video Settings...")
        av_settings_action.triggered.connect(self._open_av_settings)

        central = QWidget()
        layout = QVBoxLayout(central)
        if self.kiosk_mode:
            btn = QPushButton("Admin")
            btn.clicked.connect(self._admin_exit_kiosk)
            menubar.setCornerWidget(btn, Qt.TopRightCorner)

        self.setCentralWidget(central)

        # Header row with title and shutdown button
        header_row = QHBoxLayout()

        title = QLabel("HSPARC ‚Äî Studies")
        title.setStyleSheet("font-size:18px;font-weight:600;")
        header_row.addWidget(title)

        header_row.addStretch(1)

        # Admin exit button (only in kiosk mode)
        if self.kiosk_mode:
            btn_admin = QPushButton("üîì Admin", self)
            btn_admin.setStyleSheet("""
                QPushButton {
                    background-color: #ff6600;
                    color: white;
                    font-size: 12pt;
                    font-weight: bold;
                    padding: 8px 16px;
                    border-radius: 4px;
                }
            """)
            btn_admin.clicked.connect(self._admin_exit_kiosk)
            header_row.addWidget(btn_admin)

        # Shutdown button (only in kiosk mode)
        if self.kiosk_mode:
            self.btn_shutdown = QPushButton("‚èª Shutdown", self)
            self.btn_shutdown.setStyleSheet("""
                QPushButton {
                    background-color: #cc0000;
                    color: white;
                    font-size: 12pt;
                    padding: 10px 20px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #ff0000;
                }
            """)
            self.btn_shutdown.clicked.connect(self._shutdown_system)
            header_row.addWidget(self.btn_shutdown)

        layout.addLayout(header_row)

        # Study list with larger font
        self.study_list = QListWidget()
        self.study_list.setStyleSheet("""
            QListWidget {
                font-size: 13pt;
            }
            QListWidget::item {
                padding: 12px;
                min-height: 45px;
            }
            QListWidget::item:selected {
                background-color: #4a90d9;
                color: white;
            }
        """)
        layout.addWidget(self.study_list, 1)

        row = QHBoxLayout()
        self.btn_new_study = QPushButton("New Study")
        self.btn_open_study = QPushButton("Open Study")
        self.btn_import_study = QPushButton("Import Study‚Ä¶")
        self.btn_export_study = QPushButton("Export Study‚Ä¶")
        self.btn_delete_study = QPushButton("Delete Study‚Ä¶")
        self.btn_delete_study.setStyleSheet("background-color: #d9534f; color: white;")
        row.addWidget(self.btn_new_study)
        row.addWidget(self.btn_open_study)
        row.addWidget(self.btn_import_study)
        row.addWidget(self.btn_export_study)
        row.addWidget(self.btn_delete_study)
        layout.addLayout(row)

        self.statusBar().showMessage("Ready")
        dbm.init_db()
        self.refresh_studies()

        self.btn_new_study.clicked.connect(self.create_study)
        self.btn_open_study.clicked.connect(self.open_study)
        self.btn_import_study.clicked.connect(self.import_study_bundle)
        self.btn_export_study.clicked.connect(self.export_study)
        self.btn_delete_study.clicked.connect(self.delete_study)

        if self.kiosk_mode:
            self._add_admin_button()
            app = QApplication.instance()
            if app:
                app.installEventFilter(KioskEventFilter(app))

    def _open_av_settings(self):
        """Open A/V settings dialog."""
        dialog = AVSettingsDialog(self)
        dialog.exec()

    def _shutdown_system(self):
        """Gracefully shutdown the system."""
        reply = QMessageBox.question(
            self,
            "Shutdown System",
            "Are you sure you want to shut down the computer?\n\n"
            "All windows will be closed and the system will power off.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            print("[main] Initiating system shutdown...")

            # Close all windows gracefully
            QApplication.closeAllWindows()

            # Give time for cleanup
            time.sleep(0.5)

            # Execute shutdown command
            try:
                subprocess.run(['sudo', 'shutdown', '-h', 'now'], check=True)
            except subprocess.CalledProcessError as e:
                QMessageBox.critical(
                    self,
                    "Shutdown Failed",
                    f"Could not shut down system:\n{e}\n\n"
                    "You may need to configure passwordless sudo for shutdown."
                )
            except Exception as e:
                print(f"[main] Shutdown error: {e}")
                QMessageBox.critical(
                    self,
                    "Shutdown Failed",
                    f"Could not shut down system:\n{e}"
                )

    def _add_admin_button(self):
        """Small gear icon for admin access (only in kiosk mode)."""
        btn = QPushButton("‚öô", self)
        btn.setFixedSize(30, 30)
        btn.move(10, 10)
        btn.setStyleSheet("""
            QPushButton {
                background: rgba(255,255,255,0.1);
                border: none;
                color: #888;
                font-size: 16px;
                border-radius: 15px;
            }
            QPushButton:hover {
                background: rgba(255,255,255,0.2);
                color: #444;
            }
        """)
        btn.clicked.connect(self._admin_unlock)
        btn.raise_()

    def _admin_unlock(self):
        """Admin password entry."""
        pw, ok = QInputDialog.getText(
            self, "Admin Access",
            "Enter admin password:",
            QLineEdit.Password
        )
        if not ok or not pw:
            return

        try:
            result = subprocess.run(
                ["sudo", "-S", "-u", "admin", "whoami"],
                input=pw.encode(),
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                QMessageBox.information(self, "Admin",
                                        "Access granted. Opening file manager...")
                subprocess.Popen(["sudo", "-u", "admin", "nautilus", "/home/hsparc/.local/share/hsparc"])
            else:
                QMessageBox.warning(self, "Access Denied", "Incorrect password.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not verify: {e}")

    def refresh_studies(self):
        self.study_list.clear()
        with dbm.get_session() as s:
            studies = s.query(dbm.Study).order_by(dbm.Study.created_utc.desc()).all()
            for study in studies:
                lock_icon = "üîí "
                item = QListWidgetItem(f"{lock_icon}{study.label}  ‚Äî  {study.id[:8]}")
                item.setData(Qt.UserRole, study.id)
                self.study_list.addItem(item)

    def create_study(self):
        """Create a new study - PIN is REQUIRED."""
        label, ok = QInputDialog.getText(self, "New Study", "Study name (unique):")
        if not ok or not label.strip():
            return

        QMessageBox.information(
            self,
            "Study Security",
            "All studies require PIN protection to ensure data security.\n\n"
            "You will now set a PIN for this study."
        )

        pin = PinDialog.get_pin_from_user(
            self,
            "Set Study PIN",
            f"Enter a 4-8 digit PIN for study '{label}'.\n\n"
            "‚ö†Ô∏è Store this PIN securely - it cannot be recovered!"
        )

        if not pin:
            QMessageBox.information(self, "Cancelled", "Study creation cancelled.")
            return

        if len(pin) < 4:
            QMessageBox.warning(self, "Invalid PIN", "PIN must be at least 4 digits.")
            return

        confirm = PinDialog.get_pin_from_user(self, "Confirm PIN", "Re-enter the PIN to confirm:")
        if pin != confirm:
            QMessageBox.warning(self, "Mismatch", "PINs do not match. Study creation cancelled.")
            return

        security_hash = hash_pin(pin)

        with dbm.get_session() as s:
            if s.query(dbm.Study).filter_by(label=label.strip()).first():
                QMessageBox.warning(self, "Exists", "A study with that name already exists.")
                return

            study_id = new_uuid()
            s.add(dbm.Study(
                id=study_id,
                label=label.strip(),
                security_hash=security_hash,
                is_locked=True
            ))
            s.commit()
            log_access(study_id, "STUDY_CREATED_WITH_PIN")

        self.refresh_studies()
        QMessageBox.information(self, "Created", f"Study '{label}' created successfully.\nüîí PIN protection enabled.")

    def open_study(self):
        """Open a study - requires PIN."""
        item = self.study_list.currentItem()
        if not item:
            QMessageBox.information(self, "Pick a study", "Select a study to open.")
            return

        study_id = item.data(Qt.UserRole)

        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=study_id).first()
            if not study:
                QMessageBox.warning(self, "Missing", "Study not found.")
                return

            attempts = 0
            max_attempts = 3

            while attempts < max_attempts:
                pin = PinDialog.get_pin_from_user(
                    self,
                    "Study Locked",
                    f"Study '{study.label}' is protected.\nEnter PIN to access:"
                )

                if pin is None:
                    log_access(study_id, "ACCESS_CANCELLED")
                    return

                if verify_pin(study.security_hash, pin):
                    log_access(study_id, "ACCESS_GRANTED")
                    break
                else:
                    attempts += 1
                    remaining = max_attempts - attempts
                    log_access(study_id, f"ACCESS_DENIED_ATTEMPT_{attempts}", success=False)

                    if remaining > 0:
                        QMessageBox.warning(self, "Incorrect PIN",
                                            f"Incorrect PIN.\n{remaining} attempt(s) remaining.")
                    else:
                        QMessageBox.critical(self, "Access Denied",
                                             "Maximum attempts exceeded.\nAccess denied.")
                        return

            w = StudyWindow(study.id, study.label)
            self._child_windows.append(w)
            w.show()
            w.activateWindow()
            w.raise_()

    def export_study(self):
        """Export a study."""
        item = self.study_list.currentItem()
        if not item:
            QMessageBox.information(self, "Select Study", "Please select a study to export.")
            return

        study_id = item.data(Qt.UserRole)

        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=study_id).first()
            if not study:
                QMessageBox.warning(self, "Error", "Study not found.")
                return

            study_label = study.label

            pin = PinDialog.get_pin_from_user(
                self,
                "Export Study",
                f"Enter PIN to export study '{study_label}':"
            )

            if pin is None:
                log_access(study_id, "EXPORT_CANCELLED")
                return

            if not verify_pin(study.security_hash, pin):
                QMessageBox.warning(self, "Incorrect PIN", "Cannot export study.")
                log_access(study_id, "EXPORT_DENIED", success=False)
                return

            log_access(study_id, "EXPORT_STARTED")

        default_name = f"hsparc_study_{study_label.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.hsparc"
        export_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Study",
            str(Path.home() / default_name),
            "HSPARC Encrypted Study (*.hsparc)"
        )

        if not export_path:
            return

        progress = QProgressDialog("Exporting study...", "Cancel", 0, 100, self)
        progress.setWindowTitle("Export Study")
        progress.setWindowModality(Qt.WindowModal)
        progress.setMinimumDuration(0)
        progress.setValue(0)

        try:
            temp_zip = Path(export_path).with_suffix('.tmp.zip')
            progress.setLabelText("Creating archive...")
            progress.setValue(20)
            QApplication.processEvents()

            self._do_export_study(str(temp_zip), study_id, progress)

            if progress.wasCanceled():
                temp_zip.unlink()
                return

            progress.setLabelText("Encrypting...")
            progress.setValue(80)
            QApplication.processEvents()

            encrypt_file(str(temp_zip), pin, export_path)
            temp_zip.unlink()

            progress.setValue(100)

            QMessageBox.information(
                self,
                "Export Complete",
                f"Study exported and encrypted successfully.\n\n"
                f"File: {export_path}\n\n"
                f"‚ö†Ô∏è Keep the PIN secure - it's required to import this study!"
            )
            log_access(study_id, "EXPORT_COMPLETED")
        except Exception as e:
            QMessageBox.critical(self, "Export Failed", f"Could not export study:\n{e}")
            log_access(study_id, "EXPORT_FAILED", success=False)
            if temp_zip.exists():
                temp_zip.unlink()
        finally:
            progress.close()

    def _do_export_study(self, zip_path: str, study_id: str, progress: QProgressDialog):
        """Actually perform the export with progress updates."""
        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=study_id).first()
            if not study:
                raise ValueError("Study not found")

            recordings = s.query(dbm.Recording).filter_by(case_id=study_id).all()
            rec_ids = [r.id for r in recordings]

            sessions = s.query(dbm.ObserverSession).filter(
                dbm.ObserverSession.recording_id.in_(rec_ids)
            ).all() if rec_ids else []

            sess_ids = [ss.id for ss in sessions]

            streams = s.query(dbm.InputStream).filter(
                dbm.InputStream.session_id.in_(sess_ids)
            ).all() if sess_ids else []

            stream_ids = [st.id for st in streams]

            events = s.query(dbm.InputEvent).filter(
                dbm.InputEvent.recording_id.in_(rec_ids)
            ).all() if rec_ids else []

            progress.setValue(30)
            QApplication.processEvents()

            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
                metadata = {
                    "export_version": "1.0",
                    "export_date": datetime.utcnow().isoformat(),
                    "study": {
                        "id": study.id,
                        "label": study.label,
                        "created_utc": study.created_utc.isoformat(),
                        "security_hash": study.security_hash,
                        "is_locked": True
                    }
                }
                zf.writestr("study_metadata.json", json.dumps(metadata, indent=2))

                progress.setValue(40)
                QApplication.processEvents()

                recordings_data = []
                video_count = len([r for r in recordings if r.video_path])
                for idx, r in enumerate(recordings):
                    recordings_data.append({
                        "id": r.id,
                        "study_id": r.case_id,
                        "created_utc": r.created_utc.isoformat(),
                        "video_filename": Path(r.video_path).name if r.video_path else None,
                        "notes": r.notes
                    })

                    if r.video_path and Path(r.video_path).exists():
                        video_src = Path(r.video_path)
                        zf.write(video_src, f"recordings/{video_src.name}")
                        video_progress = 40 + int((idx + 1) / max(video_count, 1) * 30)
                        progress.setValue(video_progress)
                        progress.setLabelText(f"Adding video {idx + 1} of {video_count}...")
                        QApplication.processEvents()

                        if progress.wasCanceled():
                            return

                zf.writestr("recordings.json", json.dumps(recordings_data, indent=2))

                progress.setValue(70)
                progress.setLabelText("Adding session data...")
                QApplication.processEvents()

                sessions_data = [{
                    "id": ss.id,
                    "recording_id": ss.recording_id,
                    "created_utc": ss.created_utc.isoformat(),
                    "label": ss.label,
                    "notes": ss.notes
                } for ss in sessions]
                zf.writestr("sessions.json", json.dumps(sessions_data, indent=2))

                streams_data = [{
                    "id": st.id,
                    "session_id": st.session_id,
                    "device_name": st.device_name,
                    "profile_id": st.profile_id,
                    "created_utc": st.created_utc.isoformat(),
                    "alias": st.alias,
                    "construct_mapping": st._construct_mapping
                } for st in streams]
                zf.writestr("streams.json", json.dumps(streams_data, indent=2))

                events_data = [{
                    "id": ev.id,
                    "recording_id": ev.recording_id,
                    "session_id": ev.session_id,
                    "stream_id": ev.stream_id,
                    "t_ms": ev.t_ms,
                    "kind": ev.kind,
                    "code": ev.code,
                    "value": ev.value,
                    "is_press": ev.is_press
                } for ev in events]
                zf.writestr("events.json", json.dumps(events_data, indent=2))

                progress.setValue(75)

    def import_study_bundle(self):
        """Import a study from an encrypted .hsparc file."""
        import_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import Study",
            str(Path.home()),
            "HSPARC Encrypted Study (*.hsparc);;All Files (*)"
        )

        if not import_path:
            return

        pin = PinDialog.get_pin_from_user(
            self,
            "Import Study",
            "Enter the PIN used to encrypt this study export:"
        )

        if pin is None:
            return

        progress = QProgressDialog("Importing study...", "Cancel", 0, 100, self)
        progress.setWindowTitle("Import Study")
        progress.setWindowModality(Qt.WindowModal)
        progress.setMinimumDuration(0)
        progress.setValue(0)

        try:
            temp_zip = Path(import_path).with_suffix('.tmp.zip')

            progress.setLabelText("Decrypting...")
            progress.setValue(10)
            QApplication.processEvents()

            if not decrypt_file(import_path, pin, str(temp_zip)):
                QMessageBox.warning(
                    self,
                    "Decryption Failed",
                    "Incorrect PIN or corrupted export file."
                )
                progress.close()
                return

            progress.setValue(20)
            QApplication.processEvents()

            with zipfile.ZipFile(str(temp_zip), 'r') as zf:
                try:
                    metadata = json.loads(zf.read("study_metadata.json"))
                    study_info = metadata["study"]
                except KeyError:
                    metadata = json.loads(zf.read("case_metadata.json"))
                    study_info = metadata["case"]

            with dbm.get_session() as s:
                existing = s.query(dbm.Study).filter_by(label=study_info["label"]).first()
                if existing:
                    reply = QMessageBox.question(
                        self,
                        "Study Exists",
                        f"A study with name '{study_info['label']}' already exists.\n\n"
                        "Import with a new name?",
                        QMessageBox.Yes | QMessageBox.No
                    )

                    if reply == QMessageBox.Yes:
                        new_label, ok = QInputDialog.getText(
                            self, "New Study Name",
                            "Enter a new name for the imported study:",
                            text=f"{study_info['label']} (imported)"
                        )
                        if not ok or not new_label.strip():
                            temp_zip.unlink()
                            progress.close()
                            return
                        study_info["label"] = new_label.strip()
                    else:
                        temp_zip.unlink()
                        progress.close()
                        return

            progress.setValue(30)
            QApplication.processEvents()

            self._do_import_study(str(temp_zip), study_info, progress)

            temp_zip.unlink()

            progress.setValue(100)

            self.refresh_studies()

            QMessageBox.information(self, "Import Complete",
                                    f"Study '{study_info['label']}' imported successfully.")

        except Exception as e:
            QMessageBox.critical(self, "Import Failed", f"Could not import study:\n{e}")
            temp_zip = Path(import_path).with_suffix('.tmp.zip')
            if temp_zip.exists():
                temp_zip.unlink()
        finally:
            progress.close()

    def _do_import_study(self, zip_path: str, study_info: dict, progress: QProgressDialog):
        """Actually perform the import with progress updates."""
        with zipfile.ZipFile(zip_path, 'r') as zf:
            recordings_data = json.loads(zf.read("recordings.json"))
            sessions_data = json.loads(zf.read("sessions.json"))
            streams_data = json.loads(zf.read("streams.json"))
            events_data = json.loads(zf.read("events.json"))

            progress.setValue(40)
            progress.setLabelText("Creating study...")
            QApplication.processEvents()

            old_to_new_study_id = {study_info["id"]: new_uuid()}
            old_to_new_rec_id = {r["id"]: new_uuid() for r in recordings_data}
            old_to_new_sess_id = {s["id"]: new_uuid() for s in sessions_data}
            old_to_new_stream_id = {st["id"]: new_uuid() for st in streams_data}

            new_study_id = old_to_new_study_id[study_info["id"]]

            with dbm.get_session() as s:
                s.add(dbm.Study(
                    id=new_study_id,
                    label=study_info["label"],
                    created_utc=datetime.fromisoformat(study_info["created_utc"]),
                    security_hash=study_info.get("security_hash"),
                    is_locked=True
                ))
                s.commit()

            progress.setValue(50)
            QApplication.processEvents()

            media_dir = dbm.media_dir(new_study_id)

            video_count = len([r for r in recordings_data if r["video_filename"]])
            for idx, rec in enumerate(recordings_data):
                new_rec_id = old_to_new_rec_id[rec["id"]]

                video_path = None
                if rec["video_filename"]:
                    try:
                        video_data = zf.read(f"recordings/{rec['video_filename']}")
                        video_path = media_dir / rec["video_filename"]
                        video_path.write_bytes(video_data)
                        video_path = str(video_path)

                        video_progress = 50 + int((idx + 1) / max(video_count, 1) * 30)
                        progress.setValue(video_progress)
                        progress.setLabelText(f"Importing video {idx + 1} of {video_count}...")
                        QApplication.processEvents()

                        if progress.wasCanceled():
                            return
                    except Exception:
                        video_path = None

                with dbm.get_session() as s:
                    s.add(dbm.Recording(
                        id=new_rec_id,
                        case_id=new_study_id,
                        created_utc=datetime.fromisoformat(rec["created_utc"]),
                        video_path=video_path,
                        notes=rec["notes"]
                    ))
                    s.commit()

            progress.setValue(80)
            progress.setLabelText("Importing sessions...")
            QApplication.processEvents()

            for sess in sessions_data:
                new_sess_id = old_to_new_sess_id[sess["id"]]
                new_rec_id = old_to_new_rec_id[sess["recording_id"]]

                with dbm.get_session() as s:
                    s.add(dbm.ObserverSession(
                        id=new_sess_id,
                        recording_id=new_rec_id,
                        created_utc=datetime.fromisoformat(sess["created_utc"]),
                        label=sess["label"],
                        notes=sess["notes"]
                    ))
                    s.commit()

            progress.setValue(85)
            progress.setLabelText("Importing input streams...")
            QApplication.processEvents()

            for stream in streams_data:
                new_stream_id = old_to_new_stream_id[stream["id"]]
                new_sess_id = old_to_new_sess_id[stream["session_id"]]

                with dbm.get_session() as s:
                    s.add(dbm.InputStream(
                        id=new_stream_id,
                        session_id=new_sess_id,
                        device_name=stream["device_name"],
                        profile_id=stream["profile_id"],
                        created_utc=datetime.fromisoformat(stream["created_utc"]),
                        alias=stream["alias"],
                        _construct_mapping=stream["construct_mapping"]
                    ))
                    s.commit()

            progress.setValue(90)
            progress.setLabelText("Importing events...")
            QApplication.processEvents()

            for event in events_data:
                new_rec_id = old_to_new_rec_id[event["recording_id"]]
                new_sess_id = old_to_new_sess_id[event["session_id"]]
                new_stream_id = old_to_new_stream_id[event["stream_id"]]

                with dbm.get_session() as s:
                    s.add(dbm.InputEvent(
                        id=new_uuid(),
                        recording_id=new_rec_id,
                        session_id=new_sess_id,
                        stream_id=new_stream_id,
                        t_ms=event["t_ms"],
                        kind=event["kind"],
                        code=event["code"],
                        value=event["value"],
                        is_press=event["is_press"]
                    ))
                    s.commit()

            progress.setValue(95)

    def delete_study(self):
        """Delete a study and all its data. Requires confirmation and PIN."""
        item = self.study_list.currentItem()
        if not item:
            QMessageBox.information(self, "Select Study", "Please select a study to delete.")
            return

        study_id = item.data(Qt.UserRole)

        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=study_id).first()
            if not study:
                QMessageBox.warning(self, "Error", "Study not found.")
                return

            study_label = study.label
            security_hash = study.security_hash

            rec_count = s.query(dbm.Recording).filter_by(case_id=study_id).count()

        reply = QMessageBox.warning(
            self,
            "Delete Study",
            f"‚ö†Ô∏è DELETE STUDY: '{study_label}'\n\n"
            f"This will permanently delete:\n"
            f"  ‚Ä¢ {rec_count} recording(s) and video file(s)\n"
            f"  ‚Ä¢ All observer sessions and input data\n"
            f"  ‚Ä¢ All associated metadata\n\n"
            f"THIS CANNOT BE UNDONE!\n\n"
            f"Are you absolutely sure you want to delete this study?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            log_access(study_id, "DELETE_CANCELLED")
            return

        typed_name, ok = QInputDialog.getText(
            self,
            "Confirm Deletion",
            f"To confirm deletion, type the study name exactly:\n\n{study_label}"
        )

        if not ok or typed_name != study_label:
            QMessageBox.information(self, "Cancelled", "Deletion cancelled - name did not match.")
            log_access(study_id, "DELETE_CANCELLED")
            return

        pin = PinDialog.get_pin_from_user(
            self,
            "Delete Study - PIN Required",
            f"Enter PIN to authorize deletion of study '{study_label}':"
        )

        if pin is None:
            log_access(study_id, "DELETE_CANCELLED")
            return

        if not verify_pin(security_hash, pin):
            QMessageBox.warning(self, "Incorrect PIN", "Cannot delete study - incorrect PIN.")
            log_access(study_id, "DELETE_DENIED", success=False)
            return

        try:
            self._do_delete_study(study_id)
            QMessageBox.information(self, "Deleted", f"Study '{study_label}' has been permanently deleted.")
            log_access(study_id, "DELETE_COMPLETED")
            self.refresh_studies()
        except Exception as e:
            QMessageBox.critical(self, "Delete Failed", f"Could not delete study:\n{e}")
            log_access(study_id, "DELETE_FAILED", success=False)

    def _do_delete_study(self, study_id: str):
        """Actually delete the study and all associated data."""
        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=study_id).first()
            if not study:
                raise ValueError("Study not found")

            recordings = s.query(dbm.Recording).filter_by(case_id=study_id).all()
            for rec in recordings:
                if rec.video_path and Path(rec.video_path).exists():
                    try:
                        Path(rec.video_path).unlink()
                    except Exception:
                        pass

            media_dir = dbm.media_dir(study_id)
            if media_dir.exists():
                try:
                    shutil.rmtree(media_dir.parent)
                except Exception:
                    pass

            s.delete(study)
            s.commit()


# ========== Study Window ==========
    def _admin_exit_kiosk(self):
        """Exit kiosk mode."""
        reply = QMessageBox.question(self, "Exit", "Return to login?", QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            import subprocess
            subprocess.Popen(["sudo", "pkill", "-u", "hsparc"])
            QApplication.quit()

class StudyWindow(QMainWindow):
    def __init__(self, study_id: str, study_label: str):
        super().__init__()
        self.study_id = study_id

        self.setWindowFlags(Qt.Window)
        self.setWindowTitle(f"Study: {study_label}")
        self.resize(1150, 760)
        self._child_windows = []

        # Create menu bar with styled settings button
        menubar = self.menuBar()
        
        # Style the menubar
        menubar.setStyleSheet("""
            QMenuBar {
                background-color: #f8f9fa;
                padding: 4px;
            }
            QMenuBar::item {
                padding: 8px 16px;
                background: transparent;
                border-radius: 4px;
            }
            QMenuBar::item:selected {
                background: #e9ecef;
            }
        """)
        
        settings_menu = menubar.addMenu("‚öôÔ∏è  Settings")
        settings_menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #ddd;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #007bff;
                color: white;
            }
        """)
        
        av_settings_action = settings_menu.addAction("üé§ Audio/Video Settings...")
        av_settings_action.triggered.connect(self._open_av_settings)

        central = QWidget()
        outer = QVBoxLayout(central)
        self.setCentralWidget(central)

        header_layout = QHBoxLayout()
        hdr = QLabel(f"Recordings for study: {study_label}")
        hdr.setStyleSheet("font-size:16px;font-weight:600;")
        header_layout.addWidget(hdr)
        header_layout.addStretch(1)

        self.btn_back = QPushButton("‚Üê Back to Studies")
        self.btn_back.setStyleSheet("""
            QPushButton {
                background-color: #5bc0de;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #46b8da;
            }
        """)
        self.btn_back.clicked.connect(self.close)
        header_layout.addWidget(self.btn_back)

        outer.addLayout(header_layout)

        top_row = QHBoxLayout()
        outer.addLayout(top_row, 1)

        left = QVBoxLayout()
        top_row.addLayout(left, 1)

        # Recording list with larger font
        self.rec_list = QListWidget()
        self.rec_list.setStyleSheet("""
            QListWidget {
                font-size: 13pt;
            }
            QListWidget::item {
                padding: 12px;
                min-height: 45px;
            }
            QListWidget::item:selected {
                background-color: #4a90d9;
                color: white;
            }
        """)
        left.addWidget(self.rec_list, 1)

        row = QHBoxLayout()
        self.btn_new_rec = QPushButton("Record Video‚Ä¶")
        self.btn_import = QPushButton("Import Video‚Ä¶")
        self.btn_observer = QPushButton("Open Observer Mode")
        self.btn_researcher = QPushButton("Open Researcher Review")
        self.btn_delete_rec = QPushButton("Delete Recording‚Ä¶")
        self.btn_delete_rec.setStyleSheet("background-color: #d9534f; color: white;")
        for b in (self.btn_new_rec, self.btn_import, self.btn_observer, self.btn_researcher, self.btn_delete_rec):
            row.addWidget(b)
        left.addLayout(row)

        right = QVBoxLayout()
        top_row.addLayout(right, 2)
        self.video_title = QLabel("No recording loaded")
        self.video_title.setStyleSheet("font-weight:600;")
        right.addWidget(self.video_title)

        self._video_stack_host = QWidget()
        self._video_stack = QStackedLayout(self._video_stack_host)
        self.video_widget = QVideoWidget()
        self.video_widget.setMinimumHeight(360)
        self._video_stack.addWidget(self.video_widget)
        self.video_cover = make_cover_widget()
        self._video_stack.addWidget(self.video_cover)
        self._video_stack.setCurrentWidget(self.video_cover)
        right.addWidget(self._video_stack_host, 1)

        transport = QHBoxLayout()
        self.btn_play = QPushButton("Play")
        self.btn_pause = QPushButton("Pause")
        self.btn_stop = QPushButton("Stop")
        for b in (self.btn_play, self.btn_pause, self.btn_stop):
            transport.addWidget(b)
        right.addLayout(transport)

        # Status
        self.setCentralWidget(central)
        self.setStatusBar(self.statusBar())
        self.lbl_status = QLabel("Idle. Click 'Start Observer Session' to begin.", self)
        outer.addWidget(self.lbl_status)

        # Media player
        self.player = QMediaPlayer(self)
        self.audio = GlobalAVManager.instance().create_audio_output()
        self.player.setVideoOutput(self.video_widget)
        self.player.setAudioOutput(self.audio)

        self.btn_new_rec.clicked.connect(self.open_recorder)
        self.btn_import.clicked.connect(self.import_video)
        self.btn_observer.clicked.connect(self.open_observer_mode)
        self.btn_researcher.clicked.connect(self.open_researcher_mode)
        self.btn_delete_rec.clicked.connect(self.delete_recording)
        self.rec_list.currentItemChanged.connect(self.load_recording)
        self.btn_play.clicked.connect(self.player.play)
        self.btn_pause.clicked.connect(self.player.pause)
        self.btn_stop.clicked.connect(self.player.stop)
        self.player.mediaStatusChanged.connect(self._sync_cover_to_status)
        self.player.playbackStateChanged.connect(self._sync_cover_to_state)

        self.refresh_recordings()

    def _open_av_settings(self):
        """Open A/V settings dialog."""
        dialog = AVSettingsDialog(self)
        dialog.exec()

    def _show_cover(self, show: bool):
        self._video_stack.setCurrentWidget(self.video_cover if show else self.video_widget)

    def _sync_cover_to_status(self, status):
        good = status in (
            QMediaPlayer.MediaStatus.LoadedMedia,
            QMediaPlayer.MediaStatus.BufferedMedia,
            QMediaPlayer.MediaStatus.BufferingMedia,
            QMediaPlayer.MediaStatus.StalledMedia,
            QMediaPlayer.MediaStatus.EndOfMedia,
        )
        self._show_cover(not good)

    def _sync_cover_to_state(self, state):
        if state == QMediaPlayer.PlaybackState.StoppedState and self.player.source().isEmpty():
            self._show_cover(True)

    def refresh_recordings(self):
        self.rec_list.clear()
        with dbm.get_session() as s:
            for r in (s.query(dbm.Recording)
                    .filter_by(case_id=self.study_id)
                    .order_by(dbm.Recording.created_utc.desc()).all()):
                txt = f"{r.created_utc.strftime('%Y-%m-%d %H:%M')} ‚Äî {r.id[:8]}"
                if r.video_path:
                    txt += " (video)"
                item = QListWidgetItem(txt)
                item.setData(Qt.UserRole, {"id": r.id, "video_path": r.video_path})
                self.rec_list.addItem(item)

    def open_recorder(self):
        w = RecorderWindow(parent=self)
        for i in range(w.case_combo.count()):
            if w.case_combo.itemData(i) == self.study_id:
                w.case_combo.setCurrentIndex(i)
                break
        w.recordingSaved.connect(lambda _rid: self.refresh_recordings())
        self._child_windows.append(w)
        w.show()
        w.activateWindow()
        w.raise_()

    def import_video(self):
        fname, _ = QFileDialog.getOpenFileName(
            self, "Select video", str(Path.home()),
            "Video files (*.mp4 *.mov *.mkv *.avi);;All files (*)")
        if not fname:
            return
        src = Path(fname)
        if not src.exists():
            QMessageBox.warning(self, "Not found", "Selected file is missing.")
            return

        rec_id = new_uuid()
        dest = dbm.media_dir(self.study_id) / f"{rec_id}{(src.suffix.lower() or '.mp4')}"
        try:
            shutil.copy2(src, dest)
        except Exception as e:
            QMessageBox.critical(self, "Copy failed", f"Could not copy file:\n{e}")
            return

        sha_hex = None
        try:
            sha256 = hashlib.sha256()
            with dest.open("rb") as f:
                for chunk in iter(lambda: f.read(1024 * 1024), b""):
                    sha256.update(chunk)
            sha_hex = sha256.hexdigest()
        except Exception:
            pass

        with dbm.get_session() as s:
            s.add(dbm.Recording(
                id=rec_id, case_id=self.study_id, created_utc=datetime.utcnow(),
                video_path=str(dest),
                notes=f"Imported from {src.name} (sha256={sha_hex[:12] if sha_hex else 'n/a'})"
            ))
            s.commit()
        self.refresh_recordings()
        QMessageBox.information(self, "Imported", f"{dest}")

    def load_recording(self, curr, prev):
        if not curr:
            self.player.stop()
            self.video_title.setText("No recording loaded")
            self._show_cover(True)
            return
        meta = curr.data(Qt.UserRole) or {}
        path = meta.get("video_path")
        if not path or not Path(path).exists():
            self.player.stop()
            self.video_title.setText("Missing video")
            self._show_cover(True)
            return
        self.video_title.setText(Path(path).name)
        self.player.setSource(QUrl.fromLocalFile(path))

    def open_observer_mode(self):
        """Create an observer session and open the observer window."""
        try:
            item = self.rec_list.currentItem()
            if not item:
                QMessageBox.information(self, "Select recording", "Choose a video first.")
                return

            meta = item.data(Qt.UserRole) or {}
            video_path = meta.get("video_path")
            rec_id = meta.get("id")
            if not rec_id:
                QMessageBox.warning(self, "Missing", "Recording id missing.")
                return
            if not video_path or not Path(video_path).exists():
                QMessageBox.warning(self, "Missing video", "Recording has no playable video file.")
                return

            label, ok = QInputDialog.getText(self, "Observer Session", "Label (optional):")
            if not ok:
                return

            sess_id = new_uuid()
            ksid = new_uuid()

            with dbm.get_session() as s:
                s.add(dbm.ObserverSession(
                    id=sess_id,
                    recording_id=rec_id,
                    created_utc=datetime.utcnow(),
                    label=(label or None)
                ))
                s.add(dbm.InputStream(
                    id=ksid,
                    session_id=sess_id,
                    device_name="Keyboard",
                    profile_id="keyboard.v1",
                    created_utc=datetime.utcnow()
                ))
                s.commit()

            w = ObserverWindow(
                parent=self,
                session_id=sess_id,
                recording_id=rec_id,
                keyboard_stream_id=ksid,
                video_path=video_path,
                case_id=self.study_id
            )
            self._child_windows.append(w)
            w.show()
            w.activateWindow()
            w.raise_()

        except Exception as e:
            QMessageBox.critical(self, "Observer", f"Could not open observer window:\n{e}")

    def open_researcher_mode(self):
        item = self.rec_list.currentItem()
        if not item:
            QMessageBox.information(self, "Select recording", "Choose a video first.")
            return
        rec_id = (item.data(Qt.UserRole) or {}).get("id")
        if not rec_id:
            return
        w = ResearcherWindow(recording_id=rec_id)
        self._child_windows.append(w)
        w.show()

    def delete_recording(self):
        """Delete a recording and all its data. Requires confirmation and PIN."""
        item = self.rec_list.currentItem()
        if not item:
            QMessageBox.information(self, "Select Recording", "Please select a recording to delete.")
            return

        meta = item.data(Qt.UserRole) or {}
        rec_id = meta.get("id")
        if not rec_id:
            return

        with dbm.get_session() as s:
            study = s.query(dbm.Study).filter_by(id=self.study_id).first()
            if not study:
                QMessageBox.warning(self, "Error", "Study not found.")
                return

            security_hash = study.security_hash

            recording = s.query(dbm.Recording).filter_by(id=rec_id).first()
            if not recording:
                QMessageBox.warning(self, "Error", "Recording not found.")
                return

            rec_date = recording.created_utc.strftime('%Y-%m-%d %H:%M')
            session_count = s.query(dbm.ObserverSession).filter_by(recording_id=rec_id).count()

        reply = QMessageBox.warning(
            self,
            "Delete Recording",
            f"‚ö†Ô∏è DELETE RECORDING from {rec_date}\n\n"
            f"This will permanently delete:\n"
            f"  ‚Ä¢ The video file\n"
            f"  ‚Ä¢ {session_count} observer session(s)\n"
            f"  ‚Ä¢ All associated input streams and events\n"
            f"  ‚Ä¢ All metadata\n\n"
            f"THIS CANNOT BE UNDONE!\n\n"
            f"Are you absolutely sure you want to delete this recording?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            log_access(self.study_id, "RECORDING_DELETE_CANCELLED")
            return

        pin = PinDialog.get_pin_from_user(
            self,
            "Delete Recording - PIN Required",
            f"Enter study PIN to authorize deletion:"
        )

        if pin is None:
            log_access(self.study_id, "RECORDING_DELETE_CANCELLED")
            return

        if not verify_pin(security_hash, pin):
            QMessageBox.warning(self, "Incorrect PIN", "Cannot delete recording - incorrect PIN.")
            log_access(self.study_id, "RECORDING_DELETE_DENIED", success=False)
            return

        try:
            self._do_delete_recording(rec_id)
            QMessageBox.information(self, "Deleted", f"Recording from {rec_date} has been permanently deleted.")
            log_access(self.study_id, "RECORDING_DELETE_COMPLETED")
            self.refresh_recordings()
            self.player.stop()
            self.video_title.setText("No recording loaded")
        except Exception as e:
            QMessageBox.critical(self, "Delete Failed", f"Could not delete recording:\n{e}")
            log_access(self.study_id, "RECORDING_DELETE_FAILED", success=False)

    def _do_delete_recording(self, rec_id: str):
        """Actually delete the recording and all associated data."""
        with dbm.get_session() as s:
            recording = s.query(dbm.Recording).filter_by(id=rec_id).first()
            if not recording:
                raise ValueError("Recording not found")

            if recording.video_path and Path(recording.video_path).exists():
                try:
                    Path(recording.video_path).unlink()
                except Exception:
                    pass

            s.delete(recording)
            s.commit()


def run():
    app = QApplication(sys.argv)

    # Initialize global A/V manager
    GlobalAVManager.initialize()

    # Apply global font settings
    font = QFont()
    font.setPointSize(11)
    app.setFont(font)

    # Check if kiosk mode
    kiosk_mode = os.environ.get("HSPARC_KIOSK", "0") == "1"

    # Create background window in kiosk mode
    if kiosk_mode:
        bg = BackgroundWindow()
        bg.show()

    mw = MainWindow()
    mw.show()
    sys.exit(app.exec())
